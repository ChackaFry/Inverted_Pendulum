import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

class PIDController:
    """
    PIDController class can be used give PID controls to one input of a given system.

    Methods
    -------
    __init__(self, kp, ki, kd, ts)
        Constructor the the PIDController class.
    control(self, recorded_value, set_point=0)
        Outputs the PID controlled input for the system, based 1 recorded value, and set-point

    Attributes
    ----------
    __kp: float
        P constant
    __ki: float
        I constant
    __kd: float
        D constant
    __ts: float
        sampling time
    __err_previous = None : float
        previous value of error recorded
    __error_sum = 0 : float
        sum of all the errors
    """

    def __init__(self, kp, ki, kd, ts):
        """
        Constructor the the PIDController class.
        :param kp: float representing P constant
        :param ki: float representing I constant
        :param kd: float representing D constant
        :param ts: float representing the sampling time
        """
        self.__kp = kp  # Controller's P constant
        self.__kd = kd / ts  # Controller's D constant
        self.__ki = ki * ts  # Controller's I constant
        self.__ts = ts  # Controller's sampling time
        self.__err_previous = None  # Controller's previous error (there is no error before t = 0s)
        self.__error_sum = 0  # Controller's cumulative error

    def control(self, recorded_value, set_point=0.0):
        """
        Outputs the PID controlled input for the system, based 1 recorded value, and set-point
        :param recorded_value: float representing the recorded value
        :param set_point: float representing the set-point of the system
        :return: float representing the output generated by the controller
        """
        error = set_point - recorded_value  # Calculating the current error
        # print(error)

        output = self.__kp * error  # P Component
        output += self.__ki * (self.__error_sum + error)  # I Component

        if self.__err_previous is not None:
            output += self.__kd * (error - self.__err_previous)  # D Component

        self.__error_sum += error  # Cumulative Error
        self.__err_previous = error  # Previous Error

        return output


class InvertedPendulum:
    def __init__(self, mass_rod, mass_cart, length_rod, gravity,
                 x_pos_init=0.0, x_vel_init=0.0, rot_pos_init=0.0, rot_vel_init=0.0):
        self.__mass_rod = mass_rod
        self.__mass_cart = mass_cart
        self.__gravity = gravity
        self.__length_rod = length_rod

        self.__x_pos = x_pos_init
        self.__rot_pos = rot_pos_init
        self.__x_vel = x_vel_init
        self.__rot_vel = rot_vel_init

    def move(self, force_applied, disturbance, dt):
        init_values = self.state()
        state_values = solve_ivp(lambda time, state_in:
                                 self.car_dynamics(time, state_in, self.__mass_rod, self.__mass_cart,
                                                   self.__length_rod, self.__gravity, force_applied,
                                                   disturbance),
                                 [0, dt],
                                 init_values,
                                 t_eval=np.linspace(0, dt, 51))

        final_state = state_values.y.T[-1]
        self.__x_pos = final_state[0]
        self.__x_vel = final_state[1]
        self.__rot_pos = final_state[2]
        print(self.__rot_pos)
        self.__rot_vel = final_state[3]
        return state_values

    @staticmethod
    def car_dynamics(time, z, mass_rod, mass_cart, length_rod, gravity,
                     force_applied, disturbance):
        force_applied = force_applied + disturbance

        x_1_dot = z[1]
        x_2_dot = ((4 * mass_rod * length_rod * (z[3] ** 2) * np.sin(z[2])) + (4 * force_applied) - (
                3 * mass_rod * gravity * np.sin(z[2]) * np.cos(z[2]))) / (
                            4 * (mass_rod + mass_cart) - (3 * mass_rod * ((np.cos(z[2])) ** 2)))
        x_3_dot = z[3]
        x_4_dot = -3 * ((
                (mass_rod * length_rod * (z[3] ** 2) * np.cos(z[2]) * np.sin(z[2])) + (force_applied * np.cos(z[2])) - ((
                mass_rod + mass_cart) * (gravity * np.sin(z[2])))) / (
                              (4 * (mass_rod + mass_cart) - (3 * mass_rod * ((np.cos(z[2])) ** 2)) * length_rod)))

        return [x_1_dot, x_2_dot, x_3_dot, x_4_dot]

    def state(self):
        return self.__x_pos, self.__x_vel, self.__rot_pos, self.__rot_vel


sim_time = 30
ts = 0.1
simulations = int(sim_time / ts)

times = np.linspace(0, sim_time, 51 * simulations + 1)  # Times against which points are plotted

p, i, d = 0.2, 0.9, 0.9

controller = PIDController(p, i, d, ts)
inv = InvertedPendulum(0.1, 0.3, 0.35, 9.81)

state_recorder = [np.array(inv.state()), ]

impulse_response = np.zeros(simulations)
impulse_response[0] = 1/ts  # Area of Impulse Response is 1.
step_response = np.ones(simulations)
freq_response = np.sin(np.linspace(0, sim_time, simulations))

# Running the simulation
for sim in range(simulations):
    pid_forcing = controller.control(inv.state()[2], 0)
    state = inv.move(pid_forcing, impulse_response[sim], ts)
    state_recorder = np.vstack((state_recorder, state.y.T))

state_recorder.T[2, :] = np.rad2deg(state_recorder.T[2, :])
state_recorder.T[3, :] = np.rad2deg(state_recorder.T[3, :])

plt.title(f"Displacement of the Cart")
plt.xlabel("Time, t(s)")
plt.ylabel("Position, x(m)")
plt.plot(times, state_recorder.T[0, :])
plt.savefig("Figures\Q6_pos.eps", format="eps")
plt.show()

plt.title(f"Velocity of the Cart")
plt.xlabel("Time, t(s)")
plt.ylabel("Velocity, $\dot{x}$(m/s)")
plt.plot(times, state_recorder.T[1, :])
plt.savefig("Figures\Q6_vel.eps", format="eps")
plt.show()

plt.title(f"Response of Rod with kp={p}, ki={i}, kd={d}")
plt.plot(times, state_recorder.T[2, :])
plt.xlabel("Time, t(s)")
plt.ylabel("Rotation of Rod, θ(°)")
plt.savefig("Figures\Response_Rod_t.eps", format="eps")
plt.show()

# plt.plot(times, state_recorder.T[3, :])
# plt.show()
